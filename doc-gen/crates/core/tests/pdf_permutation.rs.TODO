//! PDF Permutation Testing (Typst)
//!
//! TODO: Port these tests to use docgen_typst::render_resume
//!
//! This test suite generates PDFs for all permutations of:
//! - All role profiles (6 profiles)
//! - Different selection configs (various bullet limits)
//! - Different bullet counts
//!
//! It analyzes:
//! - PDF size consistency
//! - Generation time
//! - PDF structure validity
//! - Page count estimates
//! - Format compliance

use docgen_core::selector::{select_bullets, SelectionConfig};
use docgen_core::{GenerationPayload, ResumeData};
use std::collections::HashMap;
use std::time::Instant;

/// Load resume data from project root
fn load_resume_data() -> ResumeData {
    let data_path = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .join("data")
        .join("resume-data.json");

    let json = std::fs::read_to_string(&data_path).unwrap_or_else(|e| {
        panic!(
            "Failed to read resume-data.json from {:?}: {}. Run npm run data:pull first",
            data_path, e
        )
    });

    serde_json::from_str(&json).expect("Failed to parse resume-data.json")
}

#[derive(Debug)]
struct PdfAnalysis {
    profile_name: String,
    profile_id: String,
    bullet_count: usize,
    config_max_bullets: usize,
    pdf_size_bytes: usize,
    generation_time_ms: u128,
    has_pdf_header: bool,
    estimated_pages: usize,
    size_per_bullet: f64,
}

impl PdfAnalysis {
    fn estimate_pages(&self) -> usize {
        // Very rough estimate: ~400 bytes per line, ~50 lines per page
        // Adjust based on empirical data
        let lines_estimate = (self.pdf_size_bytes / 400).max(1);
        (lines_estimate / 50).max(1)
    }

    fn print_summary(&self) {
        println!(
            "  ğŸ“Š {} ({} bullets): {} bytes, {}ms, ~{} pages, {:.1} bytes/bullet",
            self.profile_name,
            self.bullet_count,
            self.pdf_size_bytes,
            self.generation_time_ms,
            self.estimated_pages,
            self.size_per_bullet
        );
    }
}

fn analyze_pdf(
    profile_name: &str,
    profile_id: &str,
    bullet_count: usize,
    config_max_bullets: usize,
    pdf_bytes: &[u8],
    generation_time_ms: u128,
) -> PdfAnalysis {
    let has_pdf_header = pdf_bytes.starts_with(b"%PDF-");
    let pdf_size_bytes = pdf_bytes.len();
    let size_per_bullet = if bullet_count > 0 {
        pdf_size_bytes as f64 / bullet_count as f64
    } else {
        0.0
    };

    let analysis = PdfAnalysis {
        profile_name: profile_name.to_string(),
        profile_id: profile_id.to_string(),
        bullet_count,
        config_max_bullets,
        pdf_size_bytes,
        generation_time_ms,
        has_pdf_header,
        estimated_pages: 0, // Will be calculated
        size_per_bullet,
    };

    PdfAnalysis {
        estimated_pages: analysis.estimate_pages(),
        ..analysis
    }
}

#[test]
fn test_pdf_permutation_all_profiles_default_config() {
    println!("\nğŸ“„ PDF Permutation Test: All Profiles, Default Config");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    let resume = load_resume_data();
    let config = SelectionConfig::default();

    let mut analyses = Vec::new();

    for role_profile in resume.role_profiles.as_ref().unwrap() {
        let start = Instant::now();
        let selected = select_bullets(&resume, role_profile, &config);

        let payload = GenerationPayload {
            personal: resume.personal.clone(),
            selected_bullets: selected.clone(),
            role_profile: role_profile.clone(),
            education: resume.education.clone(),
            skills: resume.skills.clone(),
            summary: resume.summary.clone(),
            metadata: None,
        };

        let pdf_result = generate_pdf(&payload);
        let generation_time = start.elapsed().as_millis();

        assert!(
            pdf_result.is_ok(),
            "PDF generation failed for profile '{}': {:?}",
            role_profile.name,
            pdf_result.err()
        );

        let pdf_bytes = pdf_result.unwrap();

        let analysis = analyze_pdf(
            &role_profile.name,
            &role_profile.id,
            selected.len(),
            config.max_bullets,
            &pdf_bytes,
            generation_time,
        );

        analysis.print_summary();

        // Assertions
        assert!(
            analysis.has_pdf_header,
            "Missing PDF header for profile '{}'",
            role_profile.name
        );
        assert!(
            analysis.pdf_size_bytes > 1000,
            "PDF too small for profile '{}': {} bytes",
            role_profile.name,
            analysis.pdf_size_bytes
        );
        assert!(
            analysis.pdf_size_bytes < 10_000_000,
            "PDF too large for profile '{}': {} bytes",
            role_profile.name,
            analysis.pdf_size_bytes
        );

        analyses.push(analysis);
    }

    // Calculate statistics
    let total_profiles = analyses.len();
    let avg_size = analyses.iter().map(|a| a.pdf_size_bytes).sum::<usize>() / total_profiles;
    let avg_time =
        analyses.iter().map(|a| a.generation_time_ms).sum::<u128>() / total_profiles as u128;
    let max_size = analyses.iter().map(|a| a.pdf_size_bytes).max().unwrap();
    let min_size = analyses.iter().map(|a| a.pdf_size_bytes).min().unwrap();

    println!("\nğŸ“ˆ Summary Statistics:");
    println!("  Total profiles tested: {}", total_profiles);
    println!("  Average PDF size: {} bytes", avg_size);
    println!("  Size range: {} - {} bytes", min_size, max_size);
    println!("  Average generation time: {}ms", avg_time);
}

#[test]
fn test_pdf_permutation_varied_bullet_counts() {
    println!("\nğŸ“„ PDF Permutation Test: Varied Bullet Counts");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    let resume = load_resume_data();

    // Test with different max_bullets settings
    let configs = vec![
        SelectionConfig {
            max_bullets: 5,
            max_per_company: Some(3),
            max_per_position: Some(2),
        },
        SelectionConfig {
            max_bullets: 10,
            max_per_company: Some(5),
            max_per_position: Some(3),
        },
        SelectionConfig {
            max_bullets: 18,
            max_per_company: Some(6),
            max_per_position: Some(4),
        },
        SelectionConfig {
            max_bullets: 25,
            max_per_company: None,
            max_per_position: None,
        },
    ];

    let mut all_analyses = Vec::new();

    for (config_idx, config) in configs.iter().enumerate() {
        println!(
            "\nğŸ”§ Config {}: max_bullets={}",
            config_idx + 1,
            config.max_bullets
        );

        let role_profile = &resume.role_profiles.as_ref().unwrap()[0];

        let start = Instant::now();
        let selected = select_bullets(&resume, role_profile, config);

        let payload = GenerationPayload {
            personal: resume.personal.clone(),
            selected_bullets: selected.clone(),
            role_profile: role_profile.clone(),
            education: resume.education.clone(),
            skills: resume.skills.clone(),
            summary: resume.summary.clone(),
            metadata: None,
        };

        let pdf_result = generate_pdf(&payload);
        let generation_time = start.elapsed().as_millis();

        assert!(
            pdf_result.is_ok(),
            "PDF generation failed for config {}: {:?}",
            config_idx + 1,
            pdf_result.err()
        );

        let pdf_bytes = pdf_result.unwrap();

        let analysis = analyze_pdf(
            &role_profile.name,
            &role_profile.id,
            selected.len(),
            config.max_bullets,
            &pdf_bytes,
            generation_time,
        );

        analysis.print_summary();
        all_analyses.push(analysis);
    }

    // Verify size scales with bullet count
    for i in 0..all_analyses.len() - 1 {
        let current = &all_analyses[i];
        let next = &all_analyses[i + 1];

        if next.bullet_count > current.bullet_count {
            assert!(
                next.pdf_size_bytes > current.pdf_size_bytes,
                "PDF size should increase with bullet count: {} bullets ({} bytes) vs {} bullets ({} bytes)",
                current.bullet_count,
                current.pdf_size_bytes,
                next.bullet_count,
                next.pdf_size_bytes
            );
        }
    }
}

#[test]
fn test_pdf_size_consistency_across_profiles() {
    println!("\nğŸ“„ PDF Size Consistency Test");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    let resume = load_resume_data();
    let config = SelectionConfig::default();

    let mut size_per_bullet_ratios = Vec::new();

    for role_profile in resume.role_profiles.as_ref().unwrap() {
        let selected = select_bullets(&resume, role_profile, &config);

        if selected.is_empty() {
            continue;
        }

        let payload = GenerationPayload {
            personal: resume.personal.clone(),
            selected_bullets: selected.clone(),
            role_profile: role_profile.clone(),
            education: resume.education.clone(),
            skills: resume.skills.clone(),
            summary: resume.summary.clone(),
            metadata: None,
        };

        let pdf_bytes = generate_pdf(&payload).expect("PDF generation failed");

        let size_per_bullet = pdf_bytes.len() as f64 / selected.len() as f64;
        size_per_bullet_ratios.push(size_per_bullet);

        println!(
            "  {} ({} bullets): {:.1} bytes/bullet",
            role_profile.name,
            selected.len(),
            size_per_bullet
        );
    }

    // Calculate coefficient of variation (CV)
    let mean = size_per_bullet_ratios.iter().sum::<f64>() / size_per_bullet_ratios.len() as f64;
    let variance = size_per_bullet_ratios
        .iter()
        .map(|x| (x - mean).powi(2))
        .sum::<f64>()
        / size_per_bullet_ratios.len() as f64;
    let std_dev = variance.sqrt();
    let cv = std_dev / mean;

    println!("\nğŸ“Š Consistency Metrics:");
    println!("  Mean bytes/bullet: {:.1}", mean);
    println!("  Std deviation: {:.1}", std_dev);
    println!("  Coefficient of variation: {:.2}%", cv * 100.0);

    // Size per bullet should be reasonably consistent (CV < 50%)
    assert!(
        cv < 0.5,
        "Size per bullet varies too much (CV={:.2}%), may indicate layout inconsistencies",
        cv * 100.0
    );
}

#[test]
fn test_pdf_generation_performance_benchmarks() {
    println!("\nâ±ï¸  PDF Generation Performance Benchmarks");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    let resume = load_resume_data();
    let config = SelectionConfig::default();

    let mut timings = HashMap::new();

    for role_profile in resume.role_profiles.as_ref().unwrap() {
        let selected = select_bullets(&resume, role_profile, &config);

        let payload = GenerationPayload {
            personal: resume.personal.clone(),
            selected_bullets: selected.clone(),
            role_profile: role_profile.clone(),
            education: resume.education.clone(),
            skills: resume.skills.clone(),
            summary: resume.summary.clone(),
            metadata: None,
        };

        // Warm-up run
        let _ = generate_pdf(&payload);

        // Measure multiple runs
        let mut run_times = Vec::new();
        for _ in 0..5 {
            let start = Instant::now();
            let _ = generate_pdf(&payload).expect("PDF generation failed");
            run_times.push(start.elapsed().as_millis());
        }

        let avg_time = run_times.iter().sum::<u128>() / run_times.len() as u128;
        let min_time = *run_times.iter().min().unwrap();
        let max_time = *run_times.iter().max().unwrap();

        println!(
            "  {} ({} bullets): avg={}ms, min={}ms, max={}ms",
            role_profile.name,
            selected.len(),
            avg_time,
            min_time,
            max_time
        );

        timings.insert(role_profile.id.clone(), avg_time);
    }

    // All profiles should generate in < 3s
    for (profile_id, time_ms) in &timings {
        assert!(
            *time_ms < 3000,
            "Profile '{}' took {}ms (target: <3000ms)",
            profile_id,
            time_ms
        );
    }

    let overall_avg = timings.values().sum::<u128>() / timings.len() as u128;
    println!("\nğŸ“Š Overall average: {}ms", overall_avg);

    // Target: Average under 1.5s
    assert!(
        overall_avg < 1500,
        "Average generation time {}ms exceeds target (1500ms)",
        overall_avg
    );
}

#[test]
fn test_pdf_structure_validation_all_profiles() {
    println!("\nğŸ” PDF Structure Validation");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    let resume = load_resume_data();
    let config = SelectionConfig::default();

    for role_profile in resume.role_profiles.as_ref().unwrap() {
        let selected = select_bullets(&resume, role_profile, &config);

        let payload = GenerationPayload {
            personal: resume.personal.clone(),
            selected_bullets: selected.clone(),
            role_profile: role_profile.clone(),
            education: resume.education.clone(),
            skills: resume.skills.clone(),
            summary: resume.summary.clone(),
            metadata: None,
        };

        let pdf_bytes = generate_pdf(&payload).expect("PDF generation failed");

        // PDF structure validation
        assert!(
            pdf_bytes.starts_with(b"%PDF-"),
            "Profile '{}': Missing PDF magic number",
            role_profile.name
        );

        // Check for required PDF elements (as byte patterns)
        let pdf_string = String::from_utf8_lossy(&pdf_bytes);

        // Should contain xref table
        assert!(
            pdf_string.contains("xref"),
            "Profile '{}': Missing xref table",
            role_profile.name
        );

        // Should contain trailer
        assert!(
            pdf_string.contains("trailer"),
            "Profile '{}': Missing trailer",
            role_profile.name
        );

        // Should contain EOF marker
        assert!(
            pdf_bytes.ends_with(b"%%EOF") || pdf_bytes.ends_with(b"%%EOF\n"),
            "Profile '{}': Missing EOF marker",
            role_profile.name
        );

        println!("  âœ… {} - Structure valid", role_profile.name);
    }
}

#[test]
fn test_pdf_content_extraction_smoke_test() {
    println!("\nğŸ“ PDF Content Extraction (Smoke Test)");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    let resume = load_resume_data();
    let config = SelectionConfig::default();

    for role_profile in resume.role_profiles.as_ref().unwrap() {
        let selected = select_bullets(&resume, role_profile, &config);

        let payload = GenerationPayload {
            personal: resume.personal.clone(),
            selected_bullets: selected.clone(),
            role_profile: role_profile.clone(),
            education: resume.education.clone(),
            skills: resume.skills.clone(),
            summary: resume.summary.clone(),
            metadata: None,
        };

        let pdf_bytes = generate_pdf(&payload).expect("PDF generation failed");

        // Convert to string for basic content checks
        let pdf_string = String::from_utf8_lossy(&pdf_bytes);

        // Should contain personal name
        assert!(
            pdf_string.contains(&resume.personal.name),
            "Profile '{}': Personal name not found in PDF",
            role_profile.name
        );

        // Should contain at least one bullet description (if any bullets)
        if !selected.is_empty() {
            let first_bullet_desc = &selected[0].bullet.description;
            // Check first 20 chars of description (allows for formatting variations)
            let search_term = &first_bullet_desc[..first_bullet_desc.len().min(20)];

            assert!(
                pdf_string.contains(search_term),
                "Profile '{}': First bullet description not found in PDF",
                role_profile.name
            );
        }

        println!(
            "  âœ… {} - Content present ({} bullets)",
            role_profile.name,
            selected.len()
        );
    }
}

#[test]
fn test_pdf_page_count_estimates() {
    println!("\nğŸ“„ PDF Page Count Estimates");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    let resume = load_resume_data();
    let config = SelectionConfig::default();

    for role_profile in resume.role_profiles.as_ref().unwrap() {
        let selected = select_bullets(&resume, role_profile, &config);

        let payload = GenerationPayload {
            personal: resume.personal.clone(),
            selected_bullets: selected.clone(),
            role_profile: role_profile.clone(),
            education: resume.education.clone(),
            skills: resume.skills.clone(),
            summary: resume.summary.clone(),
            metadata: None,
        };

        let pdf_bytes = generate_pdf(&payload).expect("PDF generation failed");

        // Rough page estimate based on content
        let estimated_pages = {
            let base_sections = 3; // Header, summary, footer
            let bullet_lines = selected.len() * 2; // ~2 lines per bullet on average
            let total_lines = base_sections + bullet_lines;
            (total_lines / 50).max(1) // ~50 lines per page
        };

        println!(
            "  {} ({} bullets): ~{} pages, {} bytes",
            role_profile.name,
            selected.len(),
            estimated_pages,
            pdf_bytes.len()
        );

        // All PDFs should be <= 2 pages with default config (18 bullets)
        assert!(
            estimated_pages <= 2,
            "Profile '{}': Estimated {} pages (target: â‰¤2)",
            role_profile.name,
            estimated_pages
        );
    }
}
